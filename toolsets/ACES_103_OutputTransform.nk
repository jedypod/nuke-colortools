set cut_paste_input [stack 0]
push $cut_paste_input
Group {
 name ACES_103_OutputTransform
 tile_color 0xa57aaaff
 addUserKnob {20 ACES_ODT_OutputTransform_tab l "ACES ODT OutputTransform"}
 addUserKnob {35 presets t "display output presets." M {display/sRGB "knobs this \{SegmentedSplineParams_c9 0 display_pri 0 limiting_pri 0 eotf 0 dark_to_dim 1 d60_sim 0 legal_range 0 label \"sRGB\"\}" "display/sRGB D60 sim." "knobs this \{SegmentedSplineParams_c9 0 display_pri 0 limiting_pri 0 eotf 0 dark_to_dim 1 d60_sim 1 legal_range 0 label \"sRGB D60 sim.\"\}" display/Rec.709 "knobs this \{SegmentedSplineParams_c9 0 display_pri 0 limiting_pri 0 eotf 1 dark_to_dim 1 d60_sim 0 legal_range 0 label \"Rec.709\"\}" "display/Rec.709 D60 sim." "knobs this \{SegmentedSplineParams_c9 0 display_pri 0 limiting_pri 0 eotf 1 dark_to_dim 1 d60_sim 1 legal_range 0 label \"Rec.709 D60 sim.\"\}" display/Rec.2020 "knobs this \{SegmentedSplineParams_c9 0 display_pri 1 limiting_pri 1 eotf 1 dark_to_dim 1 d60_sim 0 legal_range 0 label \"Rec.2020\"\}" "display/Rec.2020 ST2084 1000nits" "knobs this \{SegmentedSplineParams_c9 1 display_pri 1 limiting_pri 1 eotf 6 dark_to_dim 1 d60_sim 0 legal_range 0 label \"Rec.2020 ST2084 1000nits\"\}" display/P3-D60 "knobs this \{SegmentedSplineParams_c9 0 display_pri 4 limiting_pri 4 eotf 4 dark_to_dim 0 d60_sim 0 legal_range 0 label \"P3-D60\"\}" "display/P3-D60 ST2084 1000nits" "knobs this \{SegmentedSplineParams_c9 1 display_pri 4 limiting_pri 4 eotf 6 dark_to_dim 0 d60_sim 0 legal_range 0 label \"P3-D60 ST2084 1000nits\"\}" "display/P3-D60 ST2084 2000nits" "knobs this \{SegmentedSplineParams_c9 2 display_pri 4 limiting_pri 4 eotf 6 dark_to_dim 0 d60_sim 0 legal_range 0 label \"P3-D60 ST2084 2000nits\"\}" "display/P3-D60 ST2084 4000nits" "knobs this \{SegmentedSplineParams_c9 3 display_pri 4 limiting_pri 4 eotf 6 dark_to_dim 0 d60_sim 0 legal_range 0 label \"P3-D60 ST2084 4000nits\"\}" display/P3-DCI "knobs this \{SegmentedSplineParams_c9 0 display_pri 3 limiting_pri 3 eotf 4 dark_to_dim 0 d60_sim 0 legal_range 0 label \"P3-DCI\"\}" display/DCDM "knobs this \{SegmentedSplineParams_c9 0 display_pri 7 limiting_pri 7 eotf 5 dark_to_dim 0 d60_sim 0 legal_range 0 label \"DCDM\"\}" "display/DCDM P3 gamut clip" "knobs this \{SegmentedSplineParams_c9 0 display_pri 7 limiting_pri 3 eotf 5 dark_to_dim 0 d60_sim 0 legal_range 0 label \"DCDM P3 gamut clip\"\}"}}
 addUserKnob {26 ""}
 addUserKnob {26 display_label l " " T "<b>Display Settings</b>"}
 addUserKnob {4 SegmentedSplineParams_c9 l "c9 params" M {ODT_48nits ODT_1000nits ODT_2000nits ODT_4000nits ""}}
 addUserKnob {26 ""}
 addUserKnob {4 display_pri l "display pri" t "Display encoding primaries." M {Rec709 Rec2020 P3D65 P3DCI P3D60 ACEScg ACES XYZ}}
 addUserKnob {4 limiting_pri l "limiting pri" t "Limiting primaries for the output transform." -STARTLINE M {Rec709 Rec2020 P3D65 P3DCI P3D60 ACEScg ACES XYZ ""}}
 addUserKnob {4 eotf l EOTF t "Electrical to Optical Transfer Function of the monitor." M {sRGB BT.1886 "Gamma 2.2" "Gamma 2.4" "Gamma 2.6" DCDM "ST-2084 (PQ)" OCES "" ""}}
 eotf BT.1886
 addUserKnob {6 dark_to_dim l "dark to dim surround" t "Apply gamma adjustment to compensate for \"Dark to Dim\" surround. For SDR outputs only." +STARTLINE}
 dark_to_dim true
 addUserKnob {6 d60_sim l "d60 sim" +STARTLINE}
 addUserKnob {6 legal_range l "legal range" t "Output legal range." +STARTLINE}
}
 BackdropNode {
  inputs 0
  name Backdrop_odt
  tile_color 0x383838ff
  label ODT
  note_font_size 51.7
  xpos -2617
  ypos -818
  bdwidth 2815
  bdheight 4324
  z_order -20
 }
 BackdropNode {
  inputs 0
  name Electrical_Optical_Transfer_Function
  tile_color 0x232323ff
  label EOTF
  note_font_size 48
  xpos -2366
  ypos 1748
  bdwidth 2210
  bdheight 1591
  z_order -10
 }
 BackdropNode {
  inputs 0
  name AP1_to_XYZ
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 90\n// Rendering primaries to XYZ\n"
  note_font_size 12
  xpos -1405
  ypos 690
  bdwidth 380
  bdheight 156
 }
 BackdropNode {
  inputs 0
  name Luminance_to_Linear_Code_Values
  tile_color 0x939393ff
  label "ACESlib.OutputTransforms.ctl : 87\n/*  Scale absolute luminance to linear code value  */\n"
  note_font_size 12
  xpos -1367
  ypos -465
  bdwidth 328
  bdheight 162
 }
 BackdropNode {
  inputs 0
  name Output_Color_Encoding_Specification
  tile_color 0x7f7f7f01
  label "Output Output Color Encoding Specification (OCES) \n- An idealized reference display with 0.0001 / 4.8 / 10000 luma\n w/ ACES AP0 Primaries."
  note_font_size 14
  xpos -1833
  ypos 1803
  bdwidth 367
  bdheight 377
 }
 BackdropNode {
  inputs 0
  name Output_Legal_Range
  tile_color 0x232323ff
  label "ACESlib.OutputTransforms.ctl : 216\n"
  note_font_size 12
  xpos -1369
  ypos 2768
  bdwidth 318
  bdheight 176
 }
 BackdropNode {
  inputs 0
  name clamp_negatives
  tile_color 0x313131ff
  label "ACESlib.OutputTransforms.ctl : 174\n// Clip values < 0 (i.e. projecting outside the display primaries)"
  note_font_size 12
  xpos -1406
  ypos 1224
  bdwidth 393
  bdheight 191
 }
 BackdropNode {
  inputs 0
  name dim_surround_gamma_adjustment
  tile_color 0x141414ff
  label "ACESlib.OutputTransforms.ctl : 92\n// Apply gamma adjustment to compensate for dim surround\n"
  note_font_size 12
  xpos -1408
  ypos 255
  bdwidth 395
  bdheight 258
 }
 BackdropNode {
  inputs 0
  name rrt_sweeteners_
  tile_color 0x5d5d5dff
  label "RRT\n"
  note_font_size 51.7
  xpos -1514
  ypos -1631
  bdwidth 609
  bdheight 766
 }
 BackdropNode {
  inputs 0
  name _EOTF_Switch_
  tile_color 0x3e3e3eff
  label "   // EOTF\n   // 0: ST-2084 (PQ)\n   // 1: BT.1886 (Rec.709/2020 settings)\n   // 2: sRGB (mon_curve w/ presets)\n   //    moncurve_r with gamma of 2.4 and \n         offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)\n   // 3: gamma 2.6\n   // 4: linear (no EOTF)\n   // 5: HLG\n6: OCES (ssts set to 0.0001, 4.8, 10000 with no EOTF and no monitor scaling = OCES)\n7: sRGB (reduced black contrast)\n\n\nsRGB\nBT.1886\nGamma 2.2\nGamma 2.4\nGamma 2.6\nST-2084 (PQ)\nHLG\nLinear"
  note_font_size 14
  xpos -1494
  ypos 2284
  bdwidth 569
  bdheight 423
  z_order 5
 }
 Input {
  inputs 0
  name Input
  xpos -1250
  ypos -1834
 }
 AddChannels {
  channels rgba
  name AddChannels
  xpos -1250
  ypos -1762
 }
 Dot {
  name Dot7
  label " ACES 2065-1 IN"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -1686
 }
 BlinkScript {
  recompileCount 87
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweetener_glow_module\" iterate pixelWise 75f48b280734753b8fc802d2ab2e3ba5f31e66e541fc1473537319fbfb99939c 2 \"src\" Read Point \"dst\" Write Point 3 \"RRT_GLOW_GAIN\" Float 1 AAAAAA== \"RRT_GLOW_MID\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 3 \"RRT_GLOW_GAIN\" 1 1 \"RRT_GLOW_MID\" 1 1 \"invert\" 1 1 0"
  kernelSource "kernel ACES_rrt_sweetener_glow_module : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float RRT_GLOW_GAIN;\n  float RRT_GLOW_MID;\n  bool invert;\n  // \"Glow\" module constants\n  // RRT_GLOW_GAIN = 0.05;\n  // RRT_GLOW_MID = 0.08;\n\n\n  float3 mult_f_f3( float x, float3 rgb) \{\n    return float3(rgb.x*x, rgb.y*x, rgb.z*x);\n  \}\n\n  float min_f3(float3 a) \{\n    return min( a.x, min( a.y, a.z));\n  \}\n\n  float max_f3(float3 a) \{\n    return max( a.x, max( a.y, a.z));\n  \}\n\n  float rgb_2_saturation( float3 rgb ) \{\n    return ( max( max_f3(rgb), 1e-10) - max( min_f3(rgb), 1e-10)) / max( max_f3(rgb), 1e-2);\n  \}\n\n  float sigmoid_shaper( float x) \{\n    float t = max( float(1. - fabs( float(x / 2.))), float(0));\n    float y = 1. + sign(float(x)) * (1. - t * t);\n    return y / 2.;\n  \}\n\n  float rgb_2_yc( float3 rgb, float ycRadiusWeight) \{\n    // keyword arguments don't work with blink.. ycRadiusWeight default if not specified was 1.75\n    float r = rgb.x; \n    float g = rgb.y; \n    float b = rgb.z;\n    float chroma = sqrt(float(b*(b-g)+g*(g-r)+r*(r-b)));\n    return ( b + g + r + ycRadiusWeight * chroma) / 3.;\n  \}\n\n  // ------- Glow module functions\n  float glow_fwd( float ycIn, float glowGainIn, float glowMid) \{\n     float glowGainOut;\n     if (ycIn <= 2./3. * glowMid) \{\n       glowGainOut = glowGainIn;\n     \} else if ( ycIn >= 2. * glowMid) \{\n       glowGainOut = 0.;\n     \} else \{\n       glowGainOut = glowGainIn * (glowMid / ycIn - 1./2.);\n     \}\n     return glowGainOut;\n  \}\n\n  float glow_inv( float ycOut, float glowGainIn, float glowMid) \{\n      float glowGainOut;\n      if (ycOut <= ((1 + glowGainIn) * 2./3. * glowMid)) \{\n        glowGainOut = -glowGainIn / (1 + glowGainIn);\n      \} else if ( ycOut >= (2. * glowMid)) \{\n        glowGainOut = 0.;\n      \} else \{\n        glowGainOut = glowGainIn * (glowMid / ycOut - 1./2.) / (glowGainIn / 2. - 1.);\n      \}\n      return glowGainOut;\n  \}\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    // --- Glow module --- //\n    float saturation = rgb_2_saturation(aces);\n    float s = sigmoid_shaper( (saturation - 0.4) / 0.2);\n    float ycIn = rgb_2_yc( aces, 1.75);\n\n    float glow;\n    if ( invert == 0 ) \{\n      glow = 1. + glow_fwd( ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n      aces = mult_f_f3( glow, aces);\n    \}\n    else \{\n      glow = 1. + glow_inv( ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\n      aces = mult_f_f3( ( glow), aces);\n    \}\n    \n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweetener_glow_module_RRT_GLOW_GAIN 0.05
  ACES_rrt_sweetener_glow_module_RRT_GLOW_MID 0.08
  rebuild_finalise ""
  name rrt_sweetener_glow_module
  selected true
  xpos -1250
  ypos -1528
 }
 BlinkScript {
  recompileCount 7
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweeteners\" iterate pixelWise d23101b5760306b7bb1c68f4211639a8c245fdfdceee957749b7d65662ae4d52 2 \"src\" Read Point \"dst\" Write Point 5 \"RRT_RED_SCALE\" Float 1 AAAAAA== \"RRT_RED_PIVOT\" Float 1 AAAAAA== \"RRT_RED_HUE\" Float 1 AAAAAA== \"RRT_RED_WIDTH\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 5 \"RRT_RED_SCALE\" 1 1 \"RRT_RED_PIVOT\" 1 1 \"RRT_RED_HUE\" 1 1 \"RRT_RED_WIDTH\" 1 1 \"invert\" 1 1 0"
  kernelSource "kernel ACES_rrt_sweeteners : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float RRT_RED_SCALE;\n  float RRT_RED_PIVOT;\n  float RRT_RED_HUE;\n  float RRT_RED_WIDTH;\n  bool invert;\n\n  // // Red modifier constants\n  // RRT_RED_SCALE = 0.82;\n  // RRT_RED_PIVOT = 0.03;\n  // RRT_RED_HUE = 0.;\n  // RRT_RED_WIDTH = 135.;\n\n\n  float min_f3(float3 a) \{\n    return min( a.x, min( a.y, a.z));\n  \}\n\n  float max_f3(float3 a) \{\n    return max( a.x, max( a.y, a.z));\n  \}\n\n  float rgb_2_saturation( float3 rgb ) \{\n    return ( max( max_f3(rgb), 1e-10) - max( min_f3(rgb), 1e-10)) / max( max_f3(rgb), 1e-2);\n  \}\n\n  float sigmoid_shaper( float x) \{\n    float t = max( float(1. - fabs( float(x / 2.))), float(0));\n    float y = 1. + sign(float(x)) * (1. - t * t);\n    return y / 2.;\n  \}\n\n  float rgb_2_yc( float3 rgb, float ycRadiusWeight) \{\n    // keyword arguments don't work with blink.. ycRadiusWeight default if not specified was 1.75\n    float r = rgb.x; \n    float g = rgb.y; \n    float b = rgb.z;\n    float chroma = sqrt(float(b*(b-g)+g*(g-r)+r*(r-b)));\n    return ( b + g + r + ycRadiusWeight * chroma) / 3.;\n  \}\n\n  // ------- Glow module functions\n  float glow_fwd( float ycIn, float glowGainIn, float glowMid) \{\n     float glowGainOut;\n     if (ycIn <= 2./3. * glowMid) \{\n       glowGainOut = glowGainIn;\n     \} else if ( ycIn >= 2. * glowMid) \{\n       glowGainOut = 0.;\n     \} else \{\n       glowGainOut = glowGainIn * (glowMid / ycIn - 1./2.);\n     \}\n     return glowGainOut;\n  \}\n\n  // Transformations from RGB to other color representations\n  float rgb_2_hue( float3 rgb) \n  \{\n    // Returns a geometric hue angle in degrees (0-360) based on RGB values.\n    // For neutral colors, hue is undefined and the function will return a quiet NaN value.\n    float hue;\n    if (rgb.x == rgb.y && rgb.y == rgb.z) \{\n      hue = 0.; // RGB triplets where RGB are equal have an undefined hue\n    \} else \{\n      hue = (180./3.14159265359) * atan2( sqrt(3)*(rgb.y-rgb.z), 2*rgb.x-rgb.y-rgb.z);\n    \}\n    if (hue < 0.) hue = hue + 360.;\n    return hue;\n  \}\n\n  float center_hue( float hue, float centerH) \{\n    float hueCentered = hue - centerH;\n    if (hueCentered < -180.) hueCentered = hueCentered + 360.;\n    else if (hueCentered > 180.) hueCentered = hueCentered - 360.;\n    return hueCentered;\n  \}\n\n  float cubic_basis_shaper( float x, float w) \{\n    float M\[4]\[4] = \{ \{ -1./6,  3./6, -3./6,  1./6 \},\n                      \{  3./6, -6./6,  3./6,  0./6 \},\n                      \{ -3./6,  0./6,  3./6,  0./6 \},\n                      \{  1./6,  4./6,  1./6,  0./6 \} \};\n    \n    double knots\[5] = \{ -w/2.,\n                       -w/4.,\n                       0.,\n                       w/4.,\n                       w/2. \};\n    float y = 0;\n    if ((x > knots\[0]) && (x < knots\[4])) \{  \n      float knot_coord = (x - knots\[0]) * 4./w;  \n      int j = knot_coord;\n      float t = knot_coord - j;\n      float monomials\[4] = \{ t*t*t, t*t, t, 1. \};\n      // (if/else structure required for compatibility with CTL < v1.5.)\n      if ( j == 3) \{\n        y = monomials\[0] * M\[0]\[0] + monomials\[1] * M\[1]\[0] + \n            monomials\[2] * M\[2]\[0] + monomials\[3] * M\[3]\[0];\n      \} else if ( j == 2) \{\n        y = monomials\[0] * M\[0]\[1] + monomials\[1] * M\[1]\[1] + \n            monomials\[2] * M\[2]\[1] + monomials\[3] * M\[3]\[1];\n      \} else if ( j == 1) \{\n        y = monomials\[0] * M\[0]\[2] + monomials\[1] * M\[1]\[2] + \n            monomials\[2] * M\[2]\[2] + monomials\[3] * M\[3]\[2];\n      \} else if ( j == 0) \{\n        y = monomials\[0] * M\[0]\[3] + monomials\[1] * M\[1]\[3] + \n            monomials\[2] * M\[2]\[3] + monomials\[3] * M\[3]\[3];\n      \} else \{\n        y = 0.0;\n      \}\n    \}\n    return y * 3/2.;\n  \}\n\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    float saturation = rgb_2_saturation(aces);\n\n    // --- Red modifier --- //\n    float hue = rgb_2_hue( aces);\n    float centeredHue = center_hue( hue, RRT_RED_HUE);\n    float hueWeight = cubic_basis_shaper( centeredHue, RRT_RED_WIDTH);\n\n    if ( invert == 0 ) \{\n      aces.x = aces.x + hueWeight * saturation * (RRT_RED_PIVOT - aces.x) * (1. - RRT_RED_SCALE);\n    \} \n    else \{ // invert red modifier: note that this is not mathematically perfect\n      float minChan;\n      if (centeredHue < 0) \{ // min_f3(aces) = aces\[1] (i.e. magenta-red)\n        minChan = aces.x;\n      \} else \{ // min_f3(aces) = aces\[2] (i.e. yellow-red)\n        minChan = aces.y;\n      \}\n      float a = hueWeight * (1. - RRT_RED_SCALE) - 1.;\n      float b = aces.x - hueWeight * (RRT_RED_PIVOT + minChan) * (1. - RRT_RED_SCALE);\n      float c = hueWeight * RRT_RED_PIVOT * minChan * (1. - RRT_RED_SCALE);\n      aces.x = ( -b - sqrt( float(b * b - 4. * a * c )) ) / ( 2. * a);\n    \}\n\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweeteners_RRT_RED_SCALE 0.82
  ACES_rrt_sweeteners_RRT_RED_PIVOT 0.03
  ACES_rrt_sweeteners_RRT_RED_WIDTH 135
  rebuild_finalise ""
  name rrt_sweetener_red_modifier
  xpos -1250
  ypos -1456
 }
 Clamp {
  channels rgb
  maximum_enable false
  name clamp_f3_min
  label "Clamp Negative Values"
  xpos -1250
  ypos -1360
 }
 ColorMatrix {
  matrix {
      {1.451439381 -0.2365107685 -0.2149285674}
      {-0.07655383646 1.176229835 -0.09967593104}
      {0.008316127583 -0.0060324613 0.997716248}
    }
  name ColorMatrix6
  label "ACES to ACEScg"
  xpos -1250
  ypos -1312
 }
 Clamp {
  channels rgb
  maximum 65535
  name clamp_f3_
  label "clamp to HALF_MAX"
  xpos -1250
  ypos -1264
 }
 BlinkScript {
  recompileCount 15
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweetener_global_desat\" iterate pixelWise c37c12c68dbaa22d98fe1eecec6f980d4704c6b9e99b3c4a0a764e65f0dc9e34 2 \"src\" Read Point \"dst\" Write Point 2 \"SAT_FACTOR\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 2 \"SAT_FACTOR\" 1 1 \"invert\" 1 1 1 \"SAT_MAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_rrt_sweetener_global_desat : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float SAT_FACTOR;\n  bool invert;\n  // // Desaturation constants\n  // RRT_SAT_FACTOR = 0.96;\n  // ODT_SAT_FACTOR = 0.93;\n\nlocal:\n  float3x3 SAT_MAT;\n\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  // Calculate RGB to XYZ 3x3 matrix given colorspace chromaticities and whitepoint\n  // and Y the luminance level of \"white\"\n  // Copying implementation from CTL source: CtlColorSpace.cpp : 77\n  float3x3 RGBtoXYZ(float2(r), float2(g), float2(b), float2(w), float Y) \{\n    // X and Z values of RGB value (1, 1, 1), or \"white\"\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n    \n    // Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr = (X * (b.y - g.y) -\n      g.x * (Y * (b.y - 1) +\n      b.y  * (X + Z)) +\n      b.x  * (Y * (g.y - 1) +\n      g.y * (X + Z))) / d;\n\n    float Sg = (X * (r.y - b.y) +\n      r.x   * (Y * (b.y - 1) +\n      b.y  * (X + Z)) -\n      b.x  * (Y * (r.y - 1) +\n      r.y   * (X + Z))) / d;\n    \n    float Sb = (X * (g.y - r.y) -\n      r.x   * (Y * (g.y - 1) +\n      g.y * (X + Z)) +\n      g.x * (Y * (r.y - 1) +\n      r.y   * (X + Z))) / d;\n    \n    // Assemble the matrix\n    float3x3 M;\n    M\[0]\[0] = Sr * r.x;\n    M\[0]\[1] = Sr * r.y;\n    M\[0]\[2] = Sr * (1 - r.x - r.y);\n    M\[1]\[0] = Sg * g.x;\n    M\[1]\[1] = Sg * g.y;\n    M\[1]\[2] = Sg * (1 - g.x - g.y);\n    M\[2]\[0] = Sb * b.x;\n    M\[2]\[1] = Sb * b.y;\n    M\[2]\[2] = Sb * (1 - b.x - b.y);\n\n    return M;\n  \}\n\n  float3x3 XYZtoRGB(float2(r), float2(g), float2(b), float2(w), float Y) \{\n    return RGBtoXYZ (r, g, b, w, Y).invert();\n  \}\n\n  float3x3 calc_sat_adjust_matrix( float sat, float3 rgb2Y) \{\n    // This function determines the terms for a 3x3 saturation matrix\n    // based on the luminance of the input.\n    float3x3 M;\n    M\[0]\[0] = (1.0 - sat) * rgb2Y.x + sat;\n    M\[1]\[0] = (1.0 - sat) * rgb2Y.x;\n    M\[2]\[0] = (1.0 - sat) * rgb2Y.x;\n    \n    M\[0]\[1] = (1.0 - sat) * rgb2Y.y;\n    M\[1]\[1] = (1.0 - sat) * rgb2Y.y + sat;\n    M\[2]\[1] = (1.0 - sat) * rgb2Y.y;\n    \n    M\[0]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[1]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[2]\[2] = (1.0 - sat) * rgb2Y.z + sat;\n\n    M.transpose();\n    return M;\n  \} \n\n  float3x3 calc_SAT_MAT() \{\n    float2 ap1_r = float2(0.713,    0.293);\n    float2 ap1_g = float2(0.165,    0.830);\n    float2 ap1_b = float2(0.128,    0.044);\n    float2 ap1_w = float2(0.32168,  0.3376);\n    float3x3 AP1_2_XYZ_MAT = RGBtoXYZ(ap1_r, ap1_g, ap1_b, ap1_w, 1.0);\n    float3 AP1_RGB2Y = float3(AP1_2_XYZ_MAT\[0]\[1], AP1_2_XYZ_MAT\[1]\[1], AP1_2_XYZ_MAT\[2]\[1]);\n    return calc_sat_adjust_matrix( SAT_FACTOR, AP1_RGB2Y);\n  \}\n\n  void init() \{\n    if (invert == 0) \{\n      SAT_MAT = calc_SAT_MAT();\n    \} else \{\n      SAT_MAT = calc_SAT_MAT();\n      SAT_MAT = SAT_MAT.invert();\n    \}\n  \}\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n    aces = mult_f3_f33( aces, SAT_MAT);\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweetener_global_desat_SAT_FACTOR 0.96
  rebuild_finalise ""
  name ACES_rrt_sweetener_global_desat4
  xpos -1250
  ypos -1174
 }
 Dot {
  name Dot23
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -1086
 }
 BlinkScript {
  recompileCount 112
  ProgramGroup 1
  KernelDescription "2 \"ACES_segmented_spline_c5\" iterate pixelWise f9840ba02d579ee036718cff4e358bef84c1dc6ec0e8f39a5ab584a6bc8e2ef8 2 \"src\" Read Point \"dst\" Write Point 1 \"invert\" Bool 1 AA== 1 \"invert\" 1 1 10 \"Min\" Float 2 1 AAAAAAAAAAA= \"Mid\" Float 2 1 AAAAAAAAAAA= \"Max\" Float 2 1 AAAAAAAAAAA= \"slopeLow\" Float 1 1 AAAAAA== \"slopeHigh\" Float 1 1 AAAAAA== \"coefsLow\" Float 1 5 AAAAAAAAAAAAAAAAAAAAAAAAAAA= \"coefsHigh\" Float 1 5 AAAAAAAAAAAAAAAAAAAAAAAAAAA= \"N_KNOTS_LOW\" Int 1 1 AAAAAA== \"N_KNOTS_HIGH\" Int 1 1 AAAAAA== \"M\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_segmented_spline_c5 : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  bool invert;\n\nlocal:\n  float2 Min;\n  float2 Mid;\n  float2 Max;\n  float slopeLow;\n  float slopeHigh;\n  float coefsLow\[5];\n  float coefsHigh\[5];\n  int N_KNOTS_LOW;\n  int N_KNOTS_HIGH;\n\n  float3x3 M;\n\n\n  // multiply a float3 by a matrix3x3\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  // dot product of two 1x3 matrices\n  float dot_f3_f3( float3 A, float3 B) \{\n    return (A.x*B.x)+(A.y*B.y)+(A.z*B.z);\n  \}\n\n  void init() \{\n\n    // Set up RRT_PARAMS\n    coefsLow\[0] = -4.0000000000;\n    coefsLow\[1] = -4.0000000000;\n    coefsLow\[2] = -3.1573765773;\n    coefsLow\[3] = -0.4852499958;\n    coefsLow\[4] = 1.8477324706;\n    coefsLow\[5] = 1.8477324706;\n\n    coefsHigh\[0] = -0.7185482425;\n    coefsHigh\[1] = 2.0810307172;\n    coefsHigh\[2] = 3.6681241237;\n    coefsHigh\[3] = 4.0000000000;\n    coefsHigh\[4] = 4.0000000000;\n    coefsHigh\[5] = 4.0000000000;\n\n    // Nota bene: It seems as though if you define an int before an array, the int\n    // could randomly get set to a really really high value :(\n    N_KNOTS_LOW = 4;\n    N_KNOTS_HIGH = 4;\n\n    // Monomial to basis function (Note: this is transposed compared to the AMPAS CTL)\n    float Marray\[] = \{0.5, -1.0, 0.5, \n                      -1.0, 1.0, 0.0, \n                      0.5, 0.5, 0.0\};\n    M.setArray(Marray);\n\n    // Explicit casts to float are necessary for log10 calls in function to work :/\n    Min = float2(float(0.18*pow(float(2), float(-15))), 0.0001);\n    Mid = float2(0.18, 4.8);\n    Max = float2(float(0.18*pow(float(2), float(18))), 10000);\n    slopeLow = 0.0;\n    slopeHigh = 0.0;\n\n\n  \}\n\n\n  float segmented_spline_c5_fwd( float x ) \{\n    // Take the log: clamp min to HALF_MIN\n    float logx = log10(max(x, 5.96046448e-08));\n    float logy;\n\n    if ( logx <= log10(Min.x) ) \{ \n      logy = logx * slopeLow + ( log10(Min.y) - slopeLow * log10(Min.x) );\n    \} \n    else if (( logx > log10(Min.x) ) && ( logx < log10(Mid.x) )) \{\n      float knot_coord = (N_KNOTS_LOW-1) * (logx-log10(Min.x))/(log10(Mid.x)-log10(Min.x));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsLow\[j], coefsLow\[j + 1], coefsLow\[j + 2]);\n      float3 monomials = float3(t * t, t, 1.0);\n      logy = dot_f3_f3( monomials, mult_f3_f33( cf, M));\n    \} \n    else if (( logx >= log10(Mid.x) ) && ( logx < log10(Max.x) )) \{\n      float knot_coord = (N_KNOTS_HIGH-1) * (logx-log10(Mid.x))/(log10(Max.x)-log10(Mid.x));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsHigh\[ j], coefsHigh\[ j + 1], coefsHigh\[ j + 2]);\n      float3 monomials = float3(t * t, t, 1. );\n      logy = dot_f3_f3( monomials, mult_f3_f33( cf, M));\n    \} \n    else \{ //if ( logIn >= log10(Max.x) ) \{ \n      logy = logx * slopeHigh + ( log10(Max.y) - slopeHigh * log10(Max.x) );\n    \}\n    return pow(10, logy);\n  \}\n\n\n\n  float segmented_spline_c5_rev( float y ) \{  \n\n\n    const float KNOT_INC_LOW = (log10(Mid.x) - log10(Min.x)) / (N_KNOTS_LOW - 1.);\n    const float KNOT_INC_HIGH = (log10(Max.x) - log10(Mid.x)) / (N_KNOTS_HIGH - 1.);\n    // return N_KNOTS_LOW;\n\n    // Setting array length to 4 manually to work around \n    // Error 1: variable length arrays are not supported in OpenCL\n    float4 KNOT_Y_LOW;\n    for (int i = 0; i < N_KNOTS_LOW; i = i+1) \{\n      KNOT_Y_LOW\[ i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.;\n    \};\n\n    float4 KNOT_Y_HIGH;\n    for (int i = 0; i < N_KNOTS_HIGH; i = i+1) \{\n      KNOT_Y_HIGH\[ i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.;\n    \};\n\n    float logy = log10( max(y, 1e-10));\n    float logx;\n\n    if (logy <= log10(Min.y)) \{\n      logx = log10(Min.x);\n    \} \n    else if ( (logy > log10(Min.y)) && (logy <= log10(Mid.y)) ) \{\n      int j;\n      float3 cf;\n      if ( logy > KNOT_Y_LOW.x && logy <= KNOT_Y_LOW.y) \{\n        cf.x = coefsLow\[0];  cf.y = coefsLow\[1];  cf.z = coefsLow\[2];  j = 0;\n      \} else if ( logy > KNOT_Y_LOW.y && logy <= KNOT_Y_LOW.z) \{\n        cf.x = coefsLow\[1];  cf.y = coefsLow\[2];  cf.z = coefsLow\[3];  j = 1;\n      \} else if ( logy > KNOT_Y_LOW.z && logy <= KNOT_Y_LOW.w ) \{\n        cf.x = coefsLow\[2];  cf.y = coefsLow\[3];  cf.z = coefsLow\[4];  j = 2;\n      \}\n      float3 tmp = mult_f3_f33( cf, M);\n      float a = tmp.x;\n      float b = tmp.y;\n      float c = tmp.z;\n      c = c - logy;\n      float d = sqrt( float(b * b - 4. * a * c));\n      float t = ( 2. * c) / ( -d - b);\n      logx = log10(Min.x) + ( t + j) * KNOT_INC_LOW;\n    \}\n    else if ( (logy > log10(Mid.y)) && (logy < log10(Max.y)) ) \{\n      int j;\n      float3 cf;\n      if ( logy > KNOT_Y_HIGH.x && logy <= KNOT_Y_HIGH.y) \{\n        cf.x = coefsHigh\[0];  cf.y = coefsHigh\[1];  cf.z = coefsHigh\[2];  j = 0;\n      \} else if ( logy > KNOT_Y_HIGH.y && logy <= KNOT_Y_HIGH.z) \{\n        cf.x = coefsHigh\[1];  cf.y = coefsHigh\[2];  cf.z = coefsHigh\[3];  j = 1;\n      \} else if ( logy > KNOT_Y_HIGH.z && logy <= KNOT_Y_HIGH.w) \{\n        cf.x = coefsHigh\[2];  cf.y = coefsHigh\[3];  cf.z = coefsHigh\[4];  j = 2;\n      \}\n      float3 tmp = mult_f3_f33( cf, M);\n      float a = tmp.x;\n      float b = tmp.y;\n      float c = tmp.z;\n      c = c - logy;\n      float d = sqrt( float(b * b - 4. * a * c));\n      float t = ( 2. * c) / ( -d - b);\n      logx = log10(Mid.x) + ( t + j) * KNOT_INC_HIGH;\n    \}\n    else \{ //if ( logy >= log10(Max.y) ) \{\n      logx = log10(Max.x);\n    \}\n    \n    return pow(10, logx);\n\n  \}\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    if (invert == 0) \{\n      aces = float3(segmented_spline_c5_fwd(aces.x), segmented_spline_c5_fwd(aces.y), segmented_spline_c5_fwd(aces.z));\n    \} else \{\n      aces = float3(segmented_spline_c5_rev(aces.x), segmented_spline_c5_rev(aces.y), segmented_spline_c5_rev(aces.z));\n    \}\n\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n \n    \}\n\};"
  rebuild ""
  rebuild_finalise ""
  name segmented_spline_c5_
  xpos -1250
  ypos -1048
 }
 ColorMatrix {
  matrix {
      {0.6954522133 0.1406786889 0.163869068}
      {0.04479460046 0.8596710563 0.09553432465}
      {-0.005525867455 0.004025223199 1.001500726}
    }
  name ColorMatrix5
  label "ACEScg to ACES"
  xpos -1250
  ypos -1000
 }
 Dot {
  name Dot24
  label " OCES OUT"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -918
 }
set N116a10f0 [stack 0]
 Dot {
  name Dot22
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1656
  ypos -918
 }
 Dot {
  name Dot21
  label " OCES"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1656
  ypos 2082
 }
push $N116a10f0
 ColorMatrix {
  matrix {
      {1.451439381 -0.2365107685 -0.2149285674}
      {-0.07655383646 1.176229835 -0.09967593104}
      {0.008316127583 -0.0060324613 0.997716248}
    }
  name ColorMatrix3
  label "ACES to ACEScg"
  xpos -1250
  ypos -760
 }
 BlinkScript {
  recompileCount 3
  ProgramGroup 1
  KernelDescription "2 \"ACES_segmented_spline_c9\" iterate pixelWise 4b980beb88a808b7875da41c3b7df42df009b5085dccf81d73bd31384e611901 2 \"src\" Read Point \"dst\" Write Point 2 \"invert\" Bool 1 AA== \"odt_type\" Int 1 AAAAAA== 2 \"invert\" 1 1 \"odt_type\" 1 1 10 \"Min\" Float 2 1 AAAAAAAAAAA= \"Mid\" Float 2 1 AAAAAAAAAAA= \"Max\" Float 2 1 AAAAAAAAAAA= \"slopeLow\" Float 1 1 AAAAAA== \"slopeHigh\" Float 1 1 AAAAAA== \"coefsLow\" Float 1 10 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"coefsHigh\" Float 1 10 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"N_KNOTS_LOW\" Int 1 1 AAAAAA== \"N_KNOTS_HIGH\" Int 1 1 AAAAAA== \"M\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_segmented_spline_c9 : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  bool invert;\n  int odt_type;\n\nlocal:\n  float2 Min;\n  float2 Mid;\n  float2 Max;\n  float slopeLow;\n  float slopeHigh;\n  float coefsLow\[10];\n  float coefsHigh\[10];\n  int N_KNOTS_LOW;\n  int N_KNOTS_HIGH;\n\n  float3x3 M;\n\n\n  // multiply a float3 by a matrix3x3\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  // dot product of two 1x3 matrices\n  float dot_f3_f3( float3 A, float3 B) \{\n    return (A.x*B.x)+(A.y*B.y)+(A.z*B.z);\n  \}\n\n  void init() \{\n\n    // Set up ODT prameters : switch with int odt_type\n    // Assigning arrays the normal way with <type> name\[] = \{val, val, val\}; doesn't work in blinkscript :(\n    // odt_type = 0 : ODT_48nits\n    if (odt_type == 0) \{\n      // coefsLow\[10]\n      coefsLow\[0] = -1.6989700043;\n      coefsLow\[1] = -1.6989700043;\n      coefsLow\[2] = -1.4779000000;\n      coefsLow\[3] = -1.2291000000;\n      coefsLow\[4] = -0.8648000000;\n      coefsLow\[5] = -0.4480000000;\n      coefsLow\[6] = 0.0051800000;\n      coefsLow\[7] = 0.4511080334;\n      coefsLow\[8] = 0.9113744414;\n      coefsLow\[9] = 0.9113744414;\n      // coefsHigh\[10]\n      coefsHigh\[0] = 0.5154386965;\n      coefsHigh\[1] = 0.8470437783;\n      coefsHigh\[2] = 1.1358000000;\n      coefsHigh\[3] = 1.3802000000;\n      coefsHigh\[4] = 1.5197000000;\n      coefsHigh\[5] = 1.5985000000;\n      coefsHigh\[6] = 1.6467000000;\n      coefsHigh\[7] = 1.6746091357;\n      coefsHigh\[8] = 1.6878733390;\n      coefsHigh\[9] = 1.6878733390;\n\n      // Explicit casts to float are necessary for log10 calls in function to work :/\n      // Explicitly calculating calls to segmented_spline_c5_fwd() to avoid having to implement this \n      // here as well.\n      Min = float2(float(0.00288), float(0.02));\n      Mid = float2(float(4.8), float(4.8));\n      Max = float2(float(1005.71936), float(48.0));\n      slopeLow = 0.0;\n      slopeHigh = 0.04;\n    \}\n    // odt_type = 1 : ODT_1000nits\n    else if (odt_type == 1) \{\n      // coefsLow\[10]\n      coefsLow\[0] = -4.9706219331;\n      coefsLow\[1] = -3.0293780669;\n      coefsLow\[2] = -2.1262;\n      coefsLow\[3] = -1.5105;\n      coefsLow\[4] = -1.0578;\n      coefsLow\[5] = -0.4668;\n      coefsLow\[6] = 0.11938;\n      coefsLow\[7] = 0.7088134201;\n      coefsLow\[8] = 1.2911865799;\n      coefsLow\[9] = 1.2911865799;\n      // coefsHigh\[10]\n      coefsHigh\[0] = 0.8089132070;\n      coefsHigh\[1] = 1.1910867930;\n      coefsHigh\[2] = 1.5683;\n      coefsHigh\[3] = 1.9483;\n      coefsHigh\[4] = 2.3083;\n      coefsHigh\[5] = 2.6384;\n      coefsHigh\[6] = 2.8595;\n      coefsHigh\[7] = 2.9872608805;\n      coefsHigh\[8] = 3.0127391195;\n      coefsHigh\[9] = 3.0127391195;\n\n      Min = float2(float(0.00014), float(0.0001));\n      Mid = float2(float(4.8), float(10));\n      Max = float2(float(4505.08447), float(1000));\n      slopeLow = 3.0;\n      slopeHigh = 0.06;\n    \}\n    // odt_type = 2 : ODT_2000nits\n    else if (odt_type == 2) \{\n      // coefsLow\[10]\n      coefsLow\[0] = -4.9706219331;\n      coefsLow\[1] = -3.0293780669;\n      coefsLow\[2] = -2.1262;\n      coefsLow\[3] = -1.5105;\n      coefsLow\[4] = -1.0578;\n      coefsLow\[5] = -0.4668;\n      coefsLow\[6] = 0.11938;\n      coefsLow\[7] = 0.7088134201;\n      coefsLow\[8] = 1.2911865799;\n      coefsLow\[9] = 1.2911865799;\n      // coefsHigh\[10]\n      coefsHigh\[0] = 0.8019952042;\n      coefsHigh\[1] = 1.1980047958;\n      coefsHigh\[2] = 1.5943000000;\n      coefsHigh\[3] = 1.9973000000;\n      coefsHigh\[4] = 2.3783000000;\n      coefsHigh\[5] = 2.7684000000;\n      coefsHigh\[6] = 3.0515000000;\n      coefsHigh\[7] = 3.2746293562;\n      coefsHigh\[8] = 3.3274306351;\n      coefsHigh\[9] = 3.3274306351;\n\n      Min = float2(float(0.00014), float(0.0001));\n      Mid = float2(float(4.8), float(10));\n      Max = float2(float(5771.86426), float(2000));\n      slopeLow = 3.0;\n      slopeHigh = 0.12;\n    \}\n    // odt_type = 3 : ODT_4000nits\n    else if (odt_type == 3) \{\n      // coefsLow\[10]\n      coefsLow\[0] = -4.9706219331;\n      coefsLow\[1] = -3.0293780669;\n      coefsLow\[2] = -2.1262;\n      coefsLow\[3] = -1.5105;\n      coefsLow\[4] = -1.0578;\n      coefsLow\[5] = -0.4668;\n      coefsLow\[6] = 0.11938;\n      coefsLow\[7] = 0.7088134201;\n      coefsLow\[8] = 1.2911865799;\n      coefsLow\[9] = 1.2911865799;\n      // coefsHigh\[10]\n      coefsHigh\[0] = 0.7973186613;\n      coefsHigh\[1] = 1.2026813387;\n      coefsHigh\[2] = 1.6093000000;\n      coefsHigh\[3] = 2.0108000000;\n      coefsHigh\[4] = 2.4148000000;\n      coefsHigh\[5] = 2.8179000000;\n      coefsHigh\[6] = 3.1725000000;\n      coefsHigh\[7] = 3.5344995451;\n      coefsHigh\[8] = 3.6696204376;\n      coefsHigh\[9] = 3.6696204376;\n\n      Min = float2(float(0.00014), float(0.0001));\n      Mid = float2(float(4.8), float(10));\n      Max = float2(float(6824.36572), float(2000));\n      slopeLow = 3.0;\n      slopeHigh = 0.3;\n    \}\n\n    // Monomial to basis function (Note: this is transposed compared to the AMPAS CTL)\n    float Marray\[] = \{0.5, -1.0, 0.5, \n                      -1.0, 1.0, 0.0, \n                      0.5, 0.5, 0.0\};\n    M.setArray(Marray);\n\n    // It seems as though if you define an int before an array, the int\n    // could randomly get set to a really really high value :(\n    N_KNOTS_LOW = 8;\n    N_KNOTS_HIGH = 8;\n  \}\n\n\n  float segmented_spline_c9_fwd( float x ) \{\n    // Take the log: clamp min to HALF_MIN\n    float logx = log10(max(x, 5.96046448e-08));\n    float logy;\n\n    if ( logx <= log10(Min.x) ) \{ \n      logy = logx * slopeLow + ( log10(Min.y) - slopeLow * log10(Min.x) );\n    \} \n    else if (( logx > log10(Min.x) ) && ( logx < log10(Mid.x) )) \{\n      float knot_coord = (N_KNOTS_LOW-1) * (logx-log10(Min.x))/(log10(Mid.x)-log10(Min.x));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsLow\[ j], coefsLow\[ j + 1], coefsLow\[ j + 2]);\n      float3 monomials = float3(t * t, t, 1. );\n      logy = dot_f3_f3( monomials, mult_f3_f33( cf, M));\n    \} \n    else if (( logx >= log10(Mid.x) ) && ( logx < log10(Max.x) )) \{\n      float knot_coord = (N_KNOTS_HIGH-1) * (logx-log10(Mid.x))/(log10(Max.x)-log10(Mid.x));\n      int j = knot_coord;\n      float t = knot_coord - j;\n      float3 cf = float3(coefsHigh\[ j], coefsHigh\[ j + 1], coefsHigh\[ j + 2]);\n      float3 monomials = float3(t * t, t, 1.);\n      logy = dot_f3_f3( monomials, mult_f3_f33( cf, M));\n    \} \n    else \{ //if ( logIn >= log10(Max.x) ) \{ \n      logy = logx * slopeHigh + ( log10(Max.y) - slopeHigh * log10(Max.x) );\n    \}\n\n    return pow(10, logy);\n  \}\n\n\n\n  float segmented_spline_c9_rev( float y ) \{  \n\n    const float KNOT_INC_LOW = (log10(Mid.x) - log10(Min.x)) / (N_KNOTS_LOW - 1.);\n    const float KNOT_INC_HIGH = (log10(Max.x) - log10(Mid.x)) / (N_KNOTS_HIGH - 1.);\n    \n    // KNOT_Y is luminance of the spline at each knot\n    // Setting array length to 4 manually to work around \n    // Error 1: variable length arrays are not supported in OpenCL\n\n    float KNOT_Y_LOW\[ 8];\n    for (int i = 0; i < N_KNOTS_LOW; i = i+1) \{\n      KNOT_Y_LOW\[ i] = ( coefsLow\[i] + coefsLow\[i+1]) / 2.;\n    \};\n\n    float KNOT_Y_HIGH\[ 8];\n    for (int i = 0; i < N_KNOTS_HIGH; i = i+1) \{\n      KNOT_Y_HIGH\[ i] = ( coefsHigh\[i] + coefsHigh\[i+1]) / 2.;\n    \};\n\n    float logy = log10( max( y, 1e-10));\n    float logx;\n\n    if (logy <= log10(Min.y)) \{\n      logx = log10(Min.x);\n    \} \n    else if ( (logy > log10(Min.y)) && (logy <= log10(Mid.y)) ) \{\n      int j;\n      float3 cf;\n      if ( logy > KNOT_Y_LOW\[ 0] && logy <= KNOT_Y_LOW\[ 1]) \{\n          cf\[ 0] = coefsLow\[0];  cf\[ 1] = coefsLow\[1];  cf\[ 2] = coefsLow\[2];  j = 0;\n      \} else if ( logy > KNOT_Y_LOW\[ 1] && logy <= KNOT_Y_LOW\[ 2]) \{\n          cf\[ 0] = coefsLow\[1];  cf\[ 1] = coefsLow\[2];  cf\[ 2] = coefsLow\[3];  j = 1;\n      \} else if ( logy > KNOT_Y_LOW\[ 2] && logy <= KNOT_Y_LOW\[ 3]) \{\n          cf\[ 0] = coefsLow\[2];  cf\[ 1] = coefsLow\[3];  cf\[ 2] = coefsLow\[4];  j = 2;\n      \} else if ( logy > KNOT_Y_LOW\[ 3] && logy <= KNOT_Y_LOW\[ 4]) \{\n          cf\[ 0] = coefsLow\[3];  cf\[ 1] = coefsLow\[4];  cf\[ 2] = coefsLow\[5];  j = 3;\n      \} else if ( logy > KNOT_Y_LOW\[ 4] && logy <= KNOT_Y_LOW\[ 5]) \{\n          cf\[ 0] = coefsLow\[4];  cf\[ 1] = coefsLow\[5];  cf\[ 2] = coefsLow\[6];  j = 4;\n      \} else if ( logy > KNOT_Y_LOW\[ 5] && logy <= KNOT_Y_LOW\[ 6]) \{\n          cf\[ 0] = coefsLow\[5];  cf\[ 1] = coefsLow\[6];  cf\[ 2] = coefsLow\[7];  j = 5;\n      \} else if ( logy > KNOT_Y_LOW\[ 6] && logy <= KNOT_Y_LOW\[ 7]) \{\n          cf\[ 0] = coefsLow\[6];  cf\[ 1] = coefsLow\[7];  cf\[ 2] = coefsLow\[8];  j = 6;\n      \}\n      \n      const float3 tmp = mult_f3_f33( cf, M);\n      float a = tmp\[ 0];\n      float b = tmp\[ 1];\n      float c = tmp\[ 2];\n      c = c - logy;\n      const float d = sqrt(float(b * b - 4. * a * c));\n      const float t = ( 2. * c) / ( -d - b);\n      logx = log10(Min.x) + ( t + j) * KNOT_INC_LOW;\n    \} \n    else if ( (logy > log10(Mid.y)) && (logy < log10(Max.y)) ) \{\n      int j;\n      float3 cf;\n      if ( logy > KNOT_Y_HIGH\[ 0] && logy <= KNOT_Y_HIGH\[ 1]) \{\n          cf\[ 0] = coefsHigh\[0];  cf\[ 1] = coefsHigh\[1];  cf\[ 2] = coefsHigh\[2];  j = 0;\n      \} else if ( logy > KNOT_Y_HIGH\[ 1] && logy <= KNOT_Y_HIGH\[ 2]) \{\n          cf\[ 0] = coefsHigh\[1];  cf\[ 1] = coefsHigh\[2];  cf\[ 2] = coefsHigh\[3];  j = 1;\n      \} else if ( logy > KNOT_Y_HIGH\[ 2] && logy <= KNOT_Y_HIGH\[ 3]) \{\n          cf\[ 0] = coefsHigh\[2];  cf\[ 1] = coefsHigh\[3];  cf\[ 2] = coefsHigh\[4];  j = 2;\n      \} else if ( logy > KNOT_Y_HIGH\[ 3] && logy <= KNOT_Y_HIGH\[ 4]) \{\n          cf\[ 0] = coefsHigh\[3];  cf\[ 1] = coefsHigh\[4];  cf\[ 2] = coefsHigh\[5];  j = 3;\n      \} else if ( logy > KNOT_Y_HIGH\[ 4] && logy <= KNOT_Y_HIGH\[ 5]) \{\n          cf\[ 0] = coefsHigh\[4];  cf\[ 1] = coefsHigh\[5];  cf\[ 2] = coefsHigh\[6];  j = 4;\n      \} else if ( logy > KNOT_Y_HIGH\[ 5] && logy <= KNOT_Y_HIGH\[ 6]) \{\n          cf\[ 0] = coefsHigh\[5];  cf\[ 1] = coefsHigh\[6];  cf\[ 2] = coefsHigh\[7];  j = 5;\n      \} else if ( logy > KNOT_Y_HIGH\[ 6] && logy <= KNOT_Y_HIGH\[ 7]) \{\n          cf\[ 0] = coefsHigh\[6];  cf\[ 1] = coefsHigh\[7];  cf\[ 2] = coefsHigh\[8];  j = 6;\n      \}\n      \n      const float3 tmp = mult_f3_f33( cf, M);\n      float a = tmp\[ 0];\n      float b = tmp\[ 1];\n      float c = tmp\[ 2];\n      c = c - logy;\n      const float d = sqrt( float(b * b - 4. * a * c));\n      const float t = ( 2. * c) / ( -d - b);\n      logx = log10(Mid.x) + ( t + j) * KNOT_INC_HIGH;\n    \} \n    else \{ //if ( logy >= log10(Max.y) ) \{\n      logx = log10(Max.x);\n    \}\n    \n    return pow(10, logx);\n\n  \}\n\n\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n\n    if (invert == 0) \{\n      aces = float3(segmented_spline_c9_fwd(aces.x), segmented_spline_c9_fwd(aces.y), segmented_spline_c9_fwd(aces.z));\n    \} else \{\n      aces = float3(segmented_spline_c9_rev(aces.x), segmented_spline_c9_rev(aces.y), segmented_spline_c9_rev(aces.z));\n    \}\n\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n \n    // dst() = float4(log10(Min.x), log10(Mid.x), N_KNOTS_LOW, N_KNOTS_HIGH);\n\n    \}\n\};"
  rebuild ""
  ACES_segmented_spline_c9_odt_type {{parent.SegmentedSplineParams_c9}}
  rebuild_finalise ""
  name segmented_spline_c9_
  xpos -1250
  ypos -664
 }
 Dot {
  name Dot25
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -534
 }
 Dot {
  name Dot11
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -414
 }
set N118ed040 [stack 0]
 Add {
  channels rgb
  value {{-pow(10,-4.4550166483)}}
  name add_f_f3_
  label "// Subtract small offset to allow for a code value of 0"
  xpos -1126
  ypos -376
 }
push $N118ed040
 Expression {
  expr0 "(r - Ymin) / (Ymax - Ymin)"
  expr1 "(g - Ymin) / (Ymax - Ymin)"
  expr2 "(b - Ymin) / (Ymax - Ymin)"
  expr3 1
  name Y_2_linCV_f3_
  xpos -1250
  ypos -370
  addUserKnob {20 Luminance}
  addUserKnob {7 Ymin R 0.0001 0.02}
  Ymin 0.02
  addUserKnob {7 Ymax R 48 10000}
  Ymax 48
 }
 Switch {
  inputs 2
  which {{parent.eotf==6}}
  name Switch_pq
  xpos -1250
  ypos -298
 }
 Dot {
  name Dot9
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -222
 }
set N11744ec0 [stack 0]
 Expression {
  temp_name0 SCALE
  temp_expr0 0.955
  expr0 "min( r, 1.0) * SCALE"
  expr1 "min( g, 1.0) * SCALE"
  expr2 "min( b, 1.0) * SCALE"
  name Expression1
  label "// Scale and clamp white to avoid casted highlights due to D60 simulation"
  xpos -1140
  ypos -232
 }
push $N11744ec0
 Switch {
  inputs 2
  which {{parent.d60_sim}}
  name Switch_d60_sim_
  xpos -1250
  ypos -178
 }
 Dot {
  name Dot12
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos -62
 }
set N116b4930 [stack 0]
 Dot {
  name Dot15
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1106
  ypos -62
 }
 Expression {
  temp_name0 tr
  temp_expr0 "(-r - c_x_0) / (c_x_1 - c_x_0)"
  temp_name1 tg
  temp_expr1 "(-g - c_x_0) / (c_x_1 - c_x_0)"
  temp_name2 tb
  temp_expr2 "(-b - c_x_0) / (c_x_1 - c_x_0)"
  expr0 "tr < 0.0 ? -(tr * c_b + c_c) : tr > 1.0 ? r : -(( tr * c_a + c_b) * tr + c_c)"
  expr1 "tg < 0.0 ? -(tg * c_b + c_c) : tg > 1.0 ? g : -(( tg * c_a + c_b) * tg + c_c)"
  expr2 "tb < 0.0 ? -(tb * c_b + c_c) : tb > 1.0 ? b : -(( tb * c_a + c_b) * tb + c_c)"
  name roll_white_fwd_
  xpos -1140
  ypos -18
  addUserKnob {20 Params}
  addUserKnob {7 new_wht}
  new_wht 0.918
  addUserKnob {7 c_width}
  c_width 0.5
  addUserKnob {7 c_x_0 +DISABLED}
  c_x_0 -1
  addUserKnob {7 c_x_1 +DISABLED}
  c_x_1 {{"c_x_0 + c_width"}}
  addUserKnob {7 c_y0 +DISABLED}
  c_y0 {{-new_wht}}
  addUserKnob {7 c_y1 +DISABLED}
  c_y1 {{c_x_1}}
  addUserKnob {7 c_m1 +DISABLED}
  c_m1 {{"(c_x_1 - c_x_0)"}}
  addUserKnob {7 c_a +DISABLED}
  c_a {{"c_y0 - c_y1 + c_m1"}}
  addUserKnob {7 c_b +DISABLED}
  c_b {{"2 * (c_y1 - c_y0) - c_m1"}}
  addUserKnob {7 c_c +DISABLED}
  c_c {{c_y0}}
 }
 Expression {
  temp_name0 SCALE
  temp_expr0 0.96
  temp_name1 NEW_WHT
  temp_expr1 0.918
  expr0 "min( r, NEW_WHT) * SCALE"
  expr1 "min( g, NEW_WHT) * SCALE"
  expr2 "min( b, NEW_WHT) * SCALE"
  name Expression2
  label "// Scale and clamp white to avoid casted highlights due to D60 simulation"
  xpos -1140
  ypos 32
 }
push $N116b4930
 Switch {
  inputs 2
  which {{"parent.display_pri == 3"}}
  name switch_wp_is_dci_
  xpos -1250
  ypos 86
 }
 Dot {
  name Dot8
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos 330
 }
set Ne148c230 [stack 0]
 Colorspace {
  colorspace_in CIE-XYZ
  colorspace_out CIE-Yxy
  name Colorspace2
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1140
  ypos 320
 }
 Clamp {
  channels {rgba.red -rgba.green -rgba.blue none}
  maximum_enable false
  name ClampMin4
  xpos -1140
  ypos 372
 }
 Expression {
  expr0 "pow(r, DIM_SURROUND_GAMMA)"
  expr1 g
  expr2 b
  channel3 none
  name dark_to_dim3
  xpos -1140
  ypos 398
  addUserKnob {20 Params}
  addUserKnob {7 DIM_SURROUND_GAMMA}
  DIM_SURROUND_GAMMA 0.9811
 }
 Colorspace {
  colorspace_in CIE-Yxy
  colorspace_out CIE-XYZ
  name Colorspace4
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1140
  ypos 440
 }
push $Ne148c230
 Switch {
  inputs 2
  which {{"(parent.eotf <= 4) ? parent.dark_to_dim : 0"}}
  name DarkToDim_Switch
  label "enable if sdr\nand dark_to_dim enabled"
  xpos -1250
  ypos 434
 }
 Dot {
  name Dot10
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos 570
 }
set N115be970 [stack 0]
 BlinkScript {
  recompileCount 15
  ProgramGroup 1
  KernelDescription "2 \"ACES_rrt_sweetener_global_desat\" iterate pixelWise c37c12c68dbaa22d98fe1eecec6f980d4704c6b9e99b3c4a0a764e65f0dc9e34 2 \"src\" Read Point \"dst\" Write Point 2 \"SAT_FACTOR\" Float 1 AAAAAA== \"invert\" Bool 1 AA== 2 \"SAT_FACTOR\" 1 1 \"invert\" 1 1 1 \"SAT_MAT\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "kernel ACES_rrt_sweetener_global_desat : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\nparam:\n  // User controllable parameters\n  float SAT_FACTOR;\n  bool invert;\n  // // Desaturation constants\n  // RRT_SAT_FACTOR = 0.96;\n  // ODT_SAT_FACTOR = 0.93;\n\nlocal:\n  float3x3 SAT_MAT;\n\n  float3 mult_f3_f33( float3 src, float3x3 mtx) \{\n    return float3(mtx\[0]\[0] * src.x + mtx\[0]\[1] * src.y + \n    mtx\[0]\[2] * src.z, mtx\[1]\[0] * src.x + mtx\[1]\[1] * src.y + \n    mtx\[1]\[2] * src.z, mtx\[2]\[0] * src.x + mtx\[2]\[1] * src.y + \n    mtx\[2]\[2] * src.z);\n  \}\n\n  // Calculate RGB to XYZ 3x3 matrix given colorspace chromaticities and whitepoint\n  // and Y the luminance level of \"white\"\n  // Copying implementation from CTL source: CtlColorSpace.cpp : 77\n  float3x3 RGBtoXYZ(float2(r), float2(g), float2(b), float2(w), float Y) \{\n    // X and Z values of RGB value (1, 1, 1), or \"white\"\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n    \n    // Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr = (X * (b.y - g.y) -\n      g.x * (Y * (b.y - 1) +\n      b.y  * (X + Z)) +\n      b.x  * (Y * (g.y - 1) +\n      g.y * (X + Z))) / d;\n\n    float Sg = (X * (r.y - b.y) +\n      r.x   * (Y * (b.y - 1) +\n      b.y  * (X + Z)) -\n      b.x  * (Y * (r.y - 1) +\n      r.y   * (X + Z))) / d;\n    \n    float Sb = (X * (g.y - r.y) -\n      r.x   * (Y * (g.y - 1) +\n      g.y * (X + Z)) +\n      g.x * (Y * (r.y - 1) +\n      r.y   * (X + Z))) / d;\n    \n    // Assemble the matrix\n    float3x3 M;\n    M\[0]\[0] = Sr * r.x;\n    M\[0]\[1] = Sr * r.y;\n    M\[0]\[2] = Sr * (1 - r.x - r.y);\n    M\[1]\[0] = Sg * g.x;\n    M\[1]\[1] = Sg * g.y;\n    M\[1]\[2] = Sg * (1 - g.x - g.y);\n    M\[2]\[0] = Sb * b.x;\n    M\[2]\[1] = Sb * b.y;\n    M\[2]\[2] = Sb * (1 - b.x - b.y);\n\n    return M;\n  \}\n\n  float3x3 XYZtoRGB(float2(r), float2(g), float2(b), float2(w), float Y) \{\n    return RGBtoXYZ (r, g, b, w, Y).invert();\n  \}\n\n  float3x3 calc_sat_adjust_matrix( float sat, float3 rgb2Y) \{\n    // This function determines the terms for a 3x3 saturation matrix\n    // based on the luminance of the input.\n    float3x3 M;\n    M\[0]\[0] = (1.0 - sat) * rgb2Y.x + sat;\n    M\[1]\[0] = (1.0 - sat) * rgb2Y.x;\n    M\[2]\[0] = (1.0 - sat) * rgb2Y.x;\n    \n    M\[0]\[1] = (1.0 - sat) * rgb2Y.y;\n    M\[1]\[1] = (1.0 - sat) * rgb2Y.y + sat;\n    M\[2]\[1] = (1.0 - sat) * rgb2Y.y;\n    \n    M\[0]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[1]\[2] = (1.0 - sat) * rgb2Y.z;\n    M\[2]\[2] = (1.0 - sat) * rgb2Y.z + sat;\n\n    M.transpose();\n    return M;\n  \} \n\n  float3x3 calc_SAT_MAT() \{\n    float2 ap1_r = float2(0.713,    0.293);\n    float2 ap1_g = float2(0.165,    0.830);\n    float2 ap1_b = float2(0.128,    0.044);\n    float2 ap1_w = float2(0.32168,  0.3376);\n    float3x3 AP1_2_XYZ_MAT = RGBtoXYZ(ap1_r, ap1_g, ap1_b, ap1_w, 1.0);\n    float3 AP1_RGB2Y = float3(AP1_2_XYZ_MAT\[0]\[1], AP1_2_XYZ_MAT\[1]\[1], AP1_2_XYZ_MAT\[2]\[1]);\n    return calc_sat_adjust_matrix( SAT_FACTOR, AP1_RGB2Y);\n  \}\n\n  void init() \{\n    if (invert == 0) \{\n      SAT_MAT = calc_SAT_MAT();\n    \} else \{\n      SAT_MAT = calc_SAT_MAT();\n      SAT_MAT = SAT_MAT.invert();\n    \}\n  \}\n\n  void process() \{\n    float3 aces = float3(src().x, src().y, src().z);\n    aces = mult_f3_f33( aces, SAT_MAT);\n    dst() = float4(aces.x, aces.y, aces.z, src().w);\n  \}\n\};"
  rebuild ""
  ACES_rrt_sweetener_global_desat_SAT_FACTOR 0.93
  rebuild_finalise ""
  name ACES_rrt_sweetener_global_desat1
  label "// Apply desaturation to compensate for luminance difference"
  xpos -1140
  ypos 578
 }
push $N115be970
 Switch {
  inputs 2
  which {{"parent.eotf < 5 && display_pri < 2"}}
  name Switch_eotf
  xpos -1250
  ypos 638
 }
 ColorMatrix {
  matrix {
      {0.6624541879 0.1340042055 0.1561876982}
      {0.2722287476 0.6740817428 0.05368951708}
      {-0.005574660841 0.004060741514 1.010339141}
    }
  name ColorMatrix1
  label "ACES AP1 to XYZ"
  xpos -1250
  ypos 776
 }
 Dot {
  name Dot19
  label " // Apply CAT from ACES white point to assumed observer adapted white point"
  note_font "Helvetica Bold"
  note_font_size 12
  note_font_color 0xa5a5a501
  xpos -1216
  ypos 882
 }
set N115ed9c0 [stack 0]
 ColorMatrix {
  matrix {
      {0.9872254133 -0.006114810705 0.01592640579}
      {-0.007603884675 1.001874804 0.005322027951}
      {0.003066040576 -0.005084238946 1.081519246}
    }
  name ColorMatrix2
  label "CAT: Bradford\n D60 to D65"
  xpos -1140
  ypos 905
 }
push $N115ed9c0
 Switch {
  inputs 2
  which {{"d60_sim ? 0 : parent.display_pri < 3"}}
  name switch_wp_is_d65_
  label "Enable CAT if wp=d65 and not d60_sim"
  xpos -1250
  ypos 935
 }
 Group {
  name limit_to_primaries
  label "// Gamut limit to limiting primaries"
  xpos -1250
  ypos 1040
  addUserKnob {20 limit_to_primaries}
  addUserKnob {4 limiting_pri l "limiting pri" M {Rec709 Rec2020 P3D65 P3DCI P3D60 ACEScg ACES XYZ}}
  limiting_pri {{parent.limiting_pri}}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -298
  }
  Dot {
   name Dot1
   label " XYZ to limiting primaries"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos -198
  }
set N11615c60 [stack 0]
push $N11615c60
  ColorMatrix {
   matrix {
       {1.049811006 0 -9.748453158e-05}
       {-0.4959030151 1.373313069 0.09824004024}
       {4.020908051e-08 0 0.9912520051}
     }
   name ColorMatrix5
   label "XYZ to ACES"
   xpos 730
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {1.641023397 -0.3248033226 -0.2364246994}
       {-0.6636629701 1.615331769 0.01675636508}
       {0.01172191743 -0.008284457959 0.9883947968}
     }
   name ColorMatrix21
   label "XYZ to ACEScg"
   xpos 620
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {2.402741432 -0.8974840641 -0.3880533576}
       {-0.8325796723 1.769231915 0.02371272631}
       {0.03882339597 -0.08249972761 1.036368608}
     }
   name ColorMatrix15
   label "XYZ to P3D60"
   xpos 510
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {2.725393534 -1.018002748 -0.4401631057}
       {-0.795167923 1.689731717 0.02264718339}
       {0.04124190658 -0.0876390487 1.100929499}
     }
   name ColorMatrix19
   label "XYZ to P3DCI"
   xpos 400
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {2.493496418 -0.9313833117 -0.4027107358}
       {-0.8294888139 1.762663841 0.02362467349}
       {0.03584583849 -0.07617240399 0.9568845034}
     }
   name ColorMatrix17
   label "XYZ to P3D65"
   xpos 290
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {1.71665132 -0.3556708097 -0.2533662617}
       {-0.6666844487 1.616481304 0.01576855592}
       {0.01763986237 -0.04277062416 0.9421030879}
     }
   name ColorMatrix12
   label "XYZ to Rec2020"
   xpos 180
   ypos -136
  }
push $N11615c60
  ColorMatrix {
   matrix {
       {3.240970135 -1.537383318 -0.4986107945}
       {-0.9692437053 1.875967622 0.04155509174}
       {0.0556300357 -0.2039768547 1.056971431}
     }
   name ColorMatrix2
   label "XYZ to Rec709"
   xpos 70
   ypos -136
  }
  Switch {
   inputs 8
   which {{parent.limiting_pri}}
   name limiting_primary_switch
   xpos -40
   ypos -34
  }
  Clamp {
   channels rgb
   maximum_enable false
   name clamp_f3
   label "Clip any values outside the limiting primaries"
   selected true
   xpos -40
   ypos 56
  }
  Dot {
   name Dot2
   label " Convert limited RGB to XYZ"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos 162
  }
set N11685b50 [stack 0]
push $N11685b50
  ColorMatrix {
   matrix {
       {0.9525524378 0 9.367863095e-05}
       {0.3439664543 0.7281661034 -0.07213255018}
       {-3.863927134e-08 0 1.008825183}
     }
   name ColorMatrix4
   label "ACES to XYZ"
   xpos 730
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.6624541879 0.1340042055 0.1561876982}
       {0.2722287476 0.6740817428 0.05368951708}
       {-0.005574660841 0.004060741514 1.010339141}
     }
   name ColorMatrix20
   label "ACEScg to XYZ"
   xpos 620
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.5049495697 0.2646814585 0.1830150485}
       {0.237623319 0.6891706586 0.07320601493}
       {0 0.0449459292 0.9638792276}
     }
   name ColorMatrix13
   label "P3D60 to XYZ"
   xpos 510
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.4451698363 0.2771343887 0.1722826511}
       {0.209491685 0.7215952873 0.06891305745}
       {0 0.04706057906 0.9073553085}
     }
   name ColorMatrix18
   label "P3DCI to XYZ"
   xpos 400
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.4865709841 0.2656676769 0.1982172877}
       {0.2289745659 0.6917385459 0.07928691059}
       {0 0.04511339962 1.043944359}
     }
   name ColorMatrix16
   label "P3D65 to XYZ"
   xpos 290
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.6369580626 0.1446169019 0.1688809693}
       {0.2627002299 0.6779980659 0.05930171534}
       {0 0.0280726999 1.060985088}
     }
   name ColorMatrix3
   label "Rec2020 to XYZ"
   xpos 180
   ypos 224
  }
push $N11685b50
  ColorMatrix {
   matrix {
       {0.4123907983 0.3575843275 0.180480808}
       {0.2126390189 0.7151686549 0.07219231874}
       {0.01933082007 0.1191947311 0.950532198}
     }
   name ColorMatrix1
   label "Rec709 to XYZ"
   xpos 70
   ypos 224
  }
  Switch {
   inputs 8
   which {{parent.limiting_pri}}
   name limiting_primary_switch1
   xpos -40
   ypos 326
  }
  Output {
   name Output
   xpos -40
   ypos 446
  }
 end_group
 Group {
  name XYZ_2_DISPLAY_PRI
  label "CIE XYZ to display encoding primaries"
  xpos -1250
  ypos 1136
  addUserKnob {20 XYZ_2_DISPLAY_PRI_tab l XYZ_2_DISPLAY_PRI}
  addUserKnob {4 display_pri l "display pri" M {Rec709 Rec2020 P3D65 P3DCI P3D60 ACEScg ACES XYZ}}
  display_pri {{parent.display_pri}}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -298
  }
  Dot {
   name Dot1
   label " XYZ to display primaries"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos -198
  }
set N1180dcf0 [stack 0]
push $N1180dcf0
  ColorMatrix {
   matrix {
       {1.049811006 0 -9.748453158e-05}
       {-0.4959030151 1.373313069 0.09824004024}
       {4.020908051e-08 0 0.9912520051}
     }
   name ColorMatrix3
   label "XYZ to ACES"
   xpos 730
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {1.641023397 -0.3248033226 -0.2364246994}
       {-0.6636629701 1.615331769 0.01675636508}
       {0.01172191743 -0.008284457959 0.9883947968}
     }
   name ColorMatrix21
   label "XYZ to ACEScg"
   xpos 620
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {2.402741432 -0.8974840641 -0.3880533576}
       {-0.8325796723 1.769231915 0.02371272631}
       {0.03882339597 -0.08249972761 1.036368608}
     }
   name ColorMatrix15
   label "XYZ to P3D60"
   xpos 510
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {2.725393534 -1.018002748 -0.4401631057}
       {-0.795167923 1.689731717 0.02264718339}
       {0.04124190658 -0.0876390487 1.100929499}
     }
   name ColorMatrix19
   label "XYZ to P3DCI"
   xpos 400
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {2.493496418 -0.9313833117 -0.4027107358}
       {-0.8294888139 1.762663841 0.02362467349}
       {0.03584583849 -0.07617240399 0.9568845034}
     }
   name ColorMatrix17
   label "XYZ to P3D65"
   xpos 290
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {1.71665132 -0.3556708097 -0.2533662617}
       {-0.6666844487 1.616481304 0.01576855592}
       {0.01763986237 -0.04277062416 0.9421030879}
     }
   name ColorMatrix12
   label "XYZ to Rec2020"
   xpos 180
   ypos -136
  }
push $N1180dcf0
  ColorMatrix {
   matrix {
       {3.240970135 -1.537383318 -0.4986107945}
       {-0.9692437053 1.875967622 0.04155509174}
       {0.0556300357 -0.2039768547 1.056971431}
     }
   name ColorMatrix2
   label "XYZ to Rec709"
   xpos 70
   ypos -136
  }
  Switch {
   inputs 8
   which {{parent.display_pri}}
   name limiting_primary_switch
   selected true
   xpos -40
   ypos -34
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Clamp {
  channels rgb
  maximum 65535
  maximum_enable false
  name clamp_f3_neg
  xpos -1250
  ypos 1334
 }
 Dot {
  name Dot1
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1216
  ypos 1866
 }
 Dot {
  name Dot3
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -1106
  ypos 1866
 }
set N118885c0 [stack 0]
 Dot {
  name Dot4
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -996
  ypos 1866
 }
set N1188d4c0 [stack 0]
 Dot {
  name Dot6
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -886
  ypos 1866
 }
set N118923c0 [stack 0]
 Dot {
  name Dot18
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -776
  ypos 1866
 }
set N118972c0 [stack 0]
 Dot {
  name Dot20
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 1866
 }
set N1189c1c0 [stack 0]
 Dot {
  name Dot2
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 1866
 }
set N118a10c0 [stack 0]
 Dot {
  name Dot5
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -446
  ypos 1866
 }
 Expression {
  temp_name0 Lm_r
  temp_expr0 "pow((r / pq_C), pq_m1)"
  temp_name1 Lm_g
  temp_expr1 "pow((g / pq_C), pq_m1)"
  temp_name2 Lm_b
  temp_expr2 "pow((b / pq_C), pq_m1)"
  expr0 "pow(( pq_c1 + pq_c2 * Lm_r ) / ( 1.0 + pq_c3 * Lm_r ), pq_m2)"
  expr1 "pow(( pq_c1 + pq_c2 * Lm_g ) / ( 1.0 + pq_c3 * Lm_g ), pq_m2)"
  expr2 "pow(( pq_c1 + pq_c2 * Lm_b ) / ( 1.0 + pq_c3 * Lm_b ), pq_m2)"
  name Y_2_ST2084_f3_1
  label "ACESlib.OutputTransforms.ctl : 243 \nACESlib.Utilities_Color.ctl : 425"
  xpos -480
  ypos 1970
  addUserKnob {20 SMPTE_ST2084-2014_Constants_tab l "Constants from SMPTE ST 2084-2014"}
  addUserKnob {7 pq_m1 t " ( 2610.0 / 4096.0 ) / 4.0;" +DISABLED R 0 100}
  pq_m1 0.1593017578
  addUserKnob {7 pq_m2 t " ( 2523.0 / 4096.0 ) * 128.0;" +DISABLED R 0 100}
  pq_m2 78.84375
  addUserKnob {7 pq_c1 t " 3424.0 / 4096.0 or pq_c3 - pq_c2 + 1.0;" +DISABLED R 0 100}
  pq_c1 0.8359375
  addUserKnob {7 pq_c2 t " ( 2413.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c2 18.8515625
  addUserKnob {7 pq_c3 t " ( 2392.0 / 4096.0 ) * 32.0;" +DISABLED R 0 100}
  pq_c3 18.6875
  addUserKnob {7 pq_C +DISABLED R 0 100}
  pq_C 10000
 }
push $N118a10c0
 Expression {
  expr0 "pow( (48./52.37) * r, 1./2.6)"
  expr1 "pow( (48./52.37) * g, 1./2.6)"
  expr2 "pow( (48./52.37) * b, 1./2.6)"
  expr3 1
  name dcdm_encode
  xpos -590
  ypos 1982
 }
push $N1189c1c0
 Expression {
  expr0 pow(r,1/gamma)
  expr1 pow(g,1/gamma)
  expr2 pow(b,1/gamma)
  name pow_f3_gamma_26_
  label "ACESlib.Utilities_Color.ctl : 260\n// Gamma 2.6"
  xpos -700
  ypos 1970
  addUserKnob {20 Gamma_tab l Gamma}
  addUserKnob {7 gamma R 0 4}
  gamma 2.6
 }
push $N118972c0
 Expression {
  expr0 pow(r,1/gamma)
  expr1 pow(g,1/gamma)
  expr2 pow(b,1/gamma)
  name pow_f3_gamma_24_
  label "ACESlib.Utilities_Color.ctl : 260\n// Gamma 2.4"
  xpos -810
  ypos 1970
  addUserKnob {20 Gamma_tab l Gamma}
  addUserKnob {7 gamma R 0 4}
  gamma 2.4
 }
push $N118923c0
 Expression {
  expr0 pow(r,1/gamma)
  expr1 pow(g,1/gamma)
  expr2 pow(b,1/gamma)
  name pow_f3_gamma_22_
  label "ACESlib.Utilities_Color.ctl : 260\n// Gamma 2.2"
  xpos -920
  ypos 1970
  addUserKnob {20 Gamma_tab l Gamma}
  addUserKnob {7 gamma R 0 4}
  gamma 2.2
 }
push $N1188d4c0
 Expression {
  temp_name0 c_a
  temp_expr0 "pow( pow( Lw, 1./gamma) - pow( Lb, 1./gamma), gamma)"
  temp_name1 c_b
  temp_expr1 "pow( Lb, 1./gamma) / ( pow( Lw, 1./gamma) - pow( Lb, 1./gamma))"
  expr0 "pow( max( r / c_a, 0.), 1.0/gamma) - c_b"
  expr1 "pow( max( g / c_a, 0.), 1.0/gamma) - c_b"
  expr2 "pow( max( b / c_a, 0.), 1.0/gamma) - c_b"
  name bt1886_r_f3
  label "ACESlib.Utilities_Color.ctl : 301\n// The reference EOTF specified in Rec. ITU-R BT.1886\n// L = a(max\[(V+b),0])^g"
  xpos -1030
  ypos 1964
  addUserKnob {20 Luminance}
  addUserKnob {7 Lw R 48 10000}
  Lw 1
  addUserKnob {7 Lb R 0.0001 0.02}
  addUserKnob {7 gamma R 1 4}
  gamma 2.4
 }
push $N118885c0
 Expression {
  temp_name0 yb
  temp_expr0 "pow( offs * gamma / ( ( gamma - 1.0) * ( 1.0 + offs)), gamma)"
  temp_name1 rs
  temp_expr1 "pow( ( gamma - 1.0) / offs, gamma - 1.0) * pow( ( 1.0 + offs) / gamma, gamma)"
  expr0 "r >= yb ? ( 1.0 + offs) * pow( r, 1.0 / gamma) - offs : r * rs"
  expr1 "g >= yb ? ( 1.0 + offs) * pow( g, 1.0 / gamma) - offs : g * rs"
  expr2 "b >= yb ? ( 1.0 + offs) * pow( b, 1.0 / gamma) - offs : b * rs"
  name moncurve_r_f3_
  label "ACESlib.Utilities_Color.ctl : 260\nmoncurve_r with gamma of 2.4 and offset of 0.055 matches the EOTF found in IEC 61966-2-1:1999 (sRGB)"
  xpos -1140
  ypos 1970
  addUserKnob {20 Luminance}
  addUserKnob {7 gamma R 0 4}
  gamma 2.4
  addUserKnob {7 offs}
  offs 0.055
 }
 Switch {
  inputs 8
  which {{parent.eotf}}
  name EOTF_Switch
  xpos -1250
  ypos 2558
 }
 Expression {
  temp_name0 REFBLACK
  temp_expr0 "64 / 1023"
  temp_name1 REFWHITE
  temp_expr1 "940 / 1023"
  expr0 "r * ( REFWHITE - REFBLACK) + REFBLACK"
  expr1 "g * ( REFWHITE - REFBLACK) + REFBLACK"
  expr2 "b * ( REFWHITE - REFBLACK) + REFBLACK"
  name fullRange_to_smpteRange_f3_
  label "ACESlib.OutputTransforms.ctl : 216"
  xpos -1250
  ypos 2840
  disable {{!parent.legal_range}}
 }
 Output {
  name Output
  xpos -1250
  ypos 3060
 }
end_group
